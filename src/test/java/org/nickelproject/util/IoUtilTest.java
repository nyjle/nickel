/*
 * Copyright (c) 2013 Numerate, Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.nickelproject.util;

import java.io.ByteArrayInputStream;
import java.util.Arrays;
import java.util.Random;

import org.apache.commons.codec.binary.Base64;
import org.junit.Assert;
import org.junit.Test;

/**
 * Unit tests for {@link IoUtil}.
 */
public final class IoUtilTest {
    private static final int testSize  = 1024;
    private static final int sizeOfInt = 4;
    
    @Test
    public void testSerializeDeserialize() throws Exception {
        for (int i = 0; i < testSize * 2; i++) {
            final int[] vInputArray = newIntArray(i);
            final byte[] vInputBytes = IoUtil.serialize(vInputArray);
            int[] vOutputArray = IoUtil.deserialize(vInputBytes);
            Arrays.equals(vInputArray, vOutputArray);

            final ByteArrayInputStream vByteArrayInputStream = new ByteArrayInputStream(vInputBytes);
            vOutputArray = IoUtil.deserialize(vByteArrayInputStream);
            Arrays.equals(vInputArray, vOutputArray);
        }
    }

    /**
     * Creates an array of ints that consume approx. <code>pNumBytes</code>
     * bytes of memory. The serialized arrays usually consume 24-27 more bytes
     * than <code>pNumBytes</code>.
     */
    private int[] newIntArray(final int pNumBytes) {
        final int[] vInts = new int[pNumBytes / sizeOfInt];
        for (int i = 0; i < vInts.length; i++) {
            vInts[i] = i;
        }
        return vInts;
    }

    @Test
    public void testDeflateZeroLength() throws Exception {
        testDeflateInflate(new byte[0]);
    }

    @Test
    public void testDeflateAllZeros() throws Exception {
        testDeflateInflate(new byte[testSize]);
    }

    @Test
    public void testDeflateMiscData() throws Exception {
        final Random vRandomizer = new Random(1234567);
        final byte[] vData = new byte[testSize];
        vRandomizer.nextBytes(vData);
        testDeflateInflate(vData);
    }

    @Test
    public void testGzipGunzip() throws Exception {
        // Gunzip...
        // This data was generated by running plain text files through GNU Gzip
        // and piping the results through `xxd -p`.
        Assert.assertEquals("", new String(IoUtil.gunzip(
                Base64.decodeBase64("H4sIAAAAAAAAAAMAAAAAAAAAAAA=")), "UTF-8"));
        Assert.assertEquals("kitty\n",
                new String(IoUtil.gunzip(Base64.decodeBase64("H4sIAAAAAAAAAMvOLCmp5AIA4Jde7gYAAAA=")),
                        "UTF-8"));

        // Gzip...
        // Note that we can't just reverse the the data above, since our Gzip
        // generates slightly different data than GNU's gzip. Hopefully it's
        // just irrelevant metadata stuff.
        // I verified that the values are gunzippable by GNU by running
        // `echo ${hex} | xxd -ps -r | gunzip -c [| wc -c]` on the hex values
        // below.
        Assert.assertEquals("H4sIAAAAAAAAAAMAAAAAAAAAAAA=",
                Base64.encodeBase64String(IoUtil.gzip("".getBytes("UTF-8"))));
        Assert.assertEquals("H4sIAAAAAAAAAMvOLCmp5AIA4Jde7gYAAAA=",
                Base64.encodeBase64String(IoUtil.gzip("kitty\n".getBytes("UTF-8"))));
    }

    private void testDeflateInflate(final byte[] pInput) throws Exception {
        final byte[] vCompressedBytes = IoUtil.deflate(pInput);
        final byte[] vUncompressedBytes = IoUtil.inflate(vCompressedBytes);
        Arrays.equals(pInput, vUncompressedBytes);
    }
}
